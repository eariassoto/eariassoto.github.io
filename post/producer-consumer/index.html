<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>
        Minimal implementations in Modern C&#43;&#43;: Producer-Consumer problem ::
        Emmanuel Arias — Blog
      </title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta
  name="description"
  content="This implementation was inspired by Stackoverflow user Yakk - Adam Nevraumont&amp;rsquo;s answer for a question about std::condition_variable. I extended it to make it a working example, and I plan to use it as a base for a new project I have in mind.
"
/>
<meta
  name="keywords"
  content=""
/>
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://eariassoto.github.io/post/producer-consumer/" />





<link rel="stylesheet" href="https://eariassoto.github.io/assets/style.css" />

<link rel="stylesheet" href="https://eariassoto.github.io/style.css" />


<link
  rel="apple-touch-icon-precomposed"
  sizes="144x144"
  href="https://eariassoto.github.io/img/apple-touch-icon-144-precomposed.png"
/>
<link rel="shortcut icon" href="https://eariassoto.github.io/img/favicon.png" />


<link href="https://eariassoto.github.io/assets/fonts/Inter-Italic.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="https://eariassoto.github.io/assets/fonts/Inter-Regular.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="https://eariassoto.github.io/assets/fonts/Inter-Medium.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="https://eariassoto.github.io/assets/fonts/Inter-MediumItalic.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="https://eariassoto.github.io/assets/fonts/Inter-Bold.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="https://eariassoto.github.io/assets/fonts/Inter-BoldItalic.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Minimal implementations in Modern C&#43;&#43;: Producer-Consumer problem"/>
<meta name="twitter:description" content="This implementation was inspired by Stackoverflow user  Yakk - Adam Nevraumont&rsquo;s answer for a question about std::condition_variable. I extended it to make it a working example, and I plan to use it as a base for a new project I have in mind."/>



<meta property="og:title" content="Minimal implementations in Modern C&#43;&#43;: Producer-Consumer problem" />
<meta property="og:description" content="This implementation was inspired by Stackoverflow user  Yakk - Adam Nevraumont&rsquo;s answer for a question about std::condition_variable. I extended it to make it a working example, and I plan to use it as a base for a new project I have in mind." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://eariassoto.github.io/post/producer-consumer/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-04-20T14:51:44+02:00" />
<meta property="article:modified_time" content="2020-04-20T14:51:44+02:00" /><meta property="og:site_name" content="Emmanuel Arias" />







  </head>
  <body class="dark-theme">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a
  href="/"
  class="logo"
  style="text-decoration: none;"
>
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367" />
</svg>
</span>
    <span class="logo__text"
      >Emmanuel Arias</span
    >
    
  
</a>

    <span class="header__right">
      
      <span class="theme-toggle">
        <svg
  class="theme-toggler"
  width="24"
  height="24"
  viewBox="0 0 48 48"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"
  />
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  
  

  <div class="post">
    <h1 class="post-title">Minimal implementations in Modern C++: Producer-Consumer problem</h1>
    <div class="post-meta">
      
        <span class="post-date">
          2020-04-20
        </span>

        
          
        
      

      


      
    </div>

    
      <span class="post-tags">
        
          <a href="https://eariassoto.github.io/tags/c&#43;&#43;/">#C&#43;&#43;</a>&nbsp;
        
          <a href="https://eariassoto.github.io/tags/design-patterns/">#Design patterns</a>&nbsp;
        
      </span>
    

    

    <div class="post-content">
      
      <p>This implementation was inspired by Stackoverflow user  <a href="https://stackoverflow.com/users/1774667/yakk-adam-nevraumont">Yakk - Adam Nevraumont</a>&rsquo;s answer for a <a href="https://stackoverflow.com/questions/57219650/stdcondition-variablenotify-all-only-wakes-up-one-thread-in-my-threadpool">question about <code>std::condition_variable</code></a>. I extended it to make it a working example, and I plan to use it as a base for a new project I have in mind.</p>
<h2 id="what-is-the-producer-consumer-problem">What is the Producer-Consumer problem?</h2>
<p>This problem is a classic example of synchronization and parallel computing. Suppose you have available multiple execution threads. In addition to that, you also have tasks that can be executed at the same time, independent from each other. The problem now is how we distribute the tasks between those threads.</p>
<p><img src="/static/img/prodcons.png" alt="Producer - Consumer problem"></p>
<p>In a simple producer-consumer problem, the producer will create tasks and push them to a queue. The queue thread will handle the synchronization. The consumer threads will wake up only when they have to execute a task. When the consumer thread finishes a task, it sleeps until the queue thread sends a new signal.</p>
<h2 id="to-the-implementation">To the implementation</h2>
<p>In C++11 a new synchronization primitive was introduced: <a href="https://en.cppreference.com/w/cpp/thread/condition_variable"><code>std::condition_variable</code></a>. This primitive allows us to block one or more threads until a shared state is modified and the thread, or threads, has been modified. This primitive needs a <code>std::mutex</code> for the blocker thread to modify the stated state, and for the blocked threads to wait on the condition variable.</p>
<p>As an overview, our producer and queue will be on the same thread. Our consumers will run on separate threads and will get the <code>std::condition_variable</code> and <code>std::mutex</code> from the queue. They will start a loop in which they will wait on the condition variable and check if there is a new task, or if the queue has stopped pushing new tasks. Our sample program will send 10 tasks, wait for an amount of time, and stop the queue.</p>
<p>The task we are going to push into the queue is going to be very simple. It will require an Id number, a duration in milliseconds, and a mutex.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span style="color:#75715e">#pragma once
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;chrono&gt;</span><span style="color:#75715e">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mutex&gt;</span><span style="color:#75715e">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span style="color:#75715e"></span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Task</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span>   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span>    Task(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> id, std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>milliseconds duration,
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span>         std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&amp;</span> coutMutex);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Execute</span>();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">GetId</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> m_Id; }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span>   <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> m_Id <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span>    std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>milliseconds m_Duration;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span>    std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&amp;</span> m_CoutMutex;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18</span>};
</code></pre></div><p>We are going to use this mutex to have exclusive use in the <code>std::cout</code> buffer. Otherwise, our messages are going to be all mixed out in the standard output.</p>
<p>The <code>Execute</code> method will also be very simple: it will sleep the thread for the <code>m_Duration</code> milliseconds, and print out this duration before exiting.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#66d9ef">void</span> Task<span style="color:#f92672">::</span>Execute() {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span>    std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>sleep_for(m_Duration);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span>    {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span>        std<span style="color:#f92672">::</span>scoped_lock<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> guard(m_CoutMutex);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5</span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Task {&#34;</span> <span style="color:#f92672">&lt;&lt;</span> m_Id <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;} finished in &#34;</span> <span style="color:#f92672">&lt;&lt;</span> m_Duration.count()
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6</span>                  <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;ms.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8</span>}
</code></pre></div><p>The <code>std::scoped_lock</code> was introduced in C++17 and it works similarly as <code>std::lock_guard</code>. One difference is that <code>std::scoped_lock</code> allows us to try to acquire more than one <code>std::mutex</code>, preventing possible deadlocks.</p>
<p>It is very important to surround the critical section in brackets. That will make the lock to release the <code>std::mutex</code> as soon as it is no longer needed. Remember that <code>std::scoped_lock</code> behaves according to the <a href="https://en.cppreference.com/w/cpp/language/raii">RAII principle</a>.</p>
<p>We are going to implement a <code>TaskQueue</code> class to wrap our <code>std::queue</code> and our synchronization mechanism.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span style="color:#75715e">#pragma once
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mutex&gt;</span><span style="color:#75715e">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;tuple&gt;</span><span style="color:#75715e">
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span><span style="color:#75715e"></span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Task</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TaskQueue</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span>   <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span>    <span style="color:#f92672">~</span>TaskQueue();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span>    <span style="color:#75715e">// Thread safe functions for producers
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PushTask</span>(Task<span style="color:#f92672">*</span> t);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PushTasks</span>(std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Task<span style="color:#f92672">*&gt;&amp;</span> tasks);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">StopQueue</span>();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span>    
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span>    <span style="color:#75715e">// Way for consumers to get the sync variables
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18</span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>tuple<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&amp;</span>, std<span style="color:#f92672">::</span>condition_variable<span style="color:#f92672">&amp;&gt;</span> Subscribe();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19</span>    
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20</span>    <span style="color:#75715e">// Non-thread safe function. Consumers must ensure
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21</span><span style="color:#75715e"></span>    <span style="color:#75715e">// lock acquisition
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">HasPendingTask</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> <span style="color:#f92672">!</span>m_Queue.empty(); }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23</span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">IsQueueStopped</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> m_QueueIsStopped; }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24</span>    Task<span style="color:#f92672">*</span> <span style="color:#a6e22e">GetNextTask</span>();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25</span>   
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26</span>   <span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27</span>    <span style="color:#66d9ef">bool</span> m_QueueIsStopped <span style="color:#f92672">=</span> false;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28</span>    std<span style="color:#f92672">::</span>queue<span style="color:#f92672">&lt;</span>Task<span style="color:#f92672">*&gt;</span> m_Queue;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29</span>    std<span style="color:#f92672">::</span>mutex m_Mutex;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30</span>    std<span style="color:#f92672">::</span>condition_variable m_ConditionVariable;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31</span>};
</code></pre></div><p>Producers will interact with this queue by pushing <code>Task</code> instances. In our case, we will handle the object destruction in the queue, but it can be improved with smart pointers. <code>StopQueue</code> will allow the producer to stop the queue and send a signal to the consumers that the queue is no longer pushing new tasks.</p>
<p>Consumers will get access to the <code>std::mutex</code>, and <code>std::condition_variable</code> to wait for new tasks. The <code>PushTask</code> and <code>PushTasks</code> functions will acquire the mutex to exclusively add new tasks. After that, the lock is no longer needed to wake up the waiting threads.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span style="color:#66d9ef">void</span> TaskQueue<span style="color:#f92672">::</span>PushTask(Task<span style="color:#f92672">*</span> t) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span>    {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span>        std<span style="color:#f92672">::</span>scoped_lock l{m_Mutex};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span>        m_Queue.push(t);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span>    m_ConditionVariable.notify_one();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span>}
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span><span style="color:#66d9ef">void</span> TaskQueue<span style="color:#f92672">::</span>PushTasks(std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Task<span style="color:#f92672">*&gt;&amp;</span> tasks) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span>    {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span>        std<span style="color:#f92672">::</span>scoped_lock l{m_Mutex};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span>        <span style="color:#66d9ef">for</span> (Task<span style="color:#f92672">*</span> t : tasks) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span>            m_Queue.push(t);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span>    m_ConditionVariable.notify_all();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span>}
</code></pre></div><p>When the consumers awake, they will use the non-thread safe functions to verify if they need to either: consume a new task, or finish execution because the queue will no longer send new tasks.</p>
<p>For the consumer thread, I will break the method for a more detailed look:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">WorkerThread</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> workerId, TaskQueue<span style="color:#f92672">&amp;</span> taskQueue,
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2</span>                  std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&amp;</span> coutMutex) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3</span>    <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> [m, cv] <span style="color:#f92672">=</span> taskQueue.Subscribe();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4</span>    
</code></pre></div><p>This declaration is a new feature introduced in C++17 called <a href="https://en.cppreference.com/w/cpp/language/structured_binding">Structured binding declaration</a>. It makes the declaration more readable, and it is the same as declaring and assigning to a <code>std::tuple</code>. Now that we have the synchronization mechanism, we can go into our main loop:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span>    <span style="color:#66d9ef">while</span> (true) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span>        <span style="color:#66d9ef">auto</span> data <span style="color:#f92672">=</span> [<span style="color:#f92672">&amp;</span>]() <span style="color:#f92672">-&gt;</span> std<span style="color:#f92672">::</span>optional<span style="color:#f92672">&lt;</span>Task<span style="color:#f92672">*&gt;</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span>            std<span style="color:#f92672">::</span>unique_lock l{m};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span>            cv.wait(l, [<span style="color:#f92672">&amp;</span>] {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span>                <span style="color:#66d9ef">return</span> taskQueue.IsQueueStopped() <span style="color:#f92672">||</span> taskQueue.HasPendingTask();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span>            });
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span>            <span style="color:#66d9ef">if</span> (taskQueue.IsQueueStopped()) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span>                <span style="color:#66d9ef">return</span> {};
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span>            } <span style="color:#66d9ef">else</span> {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span>                Task<span style="color:#f92672">*</span> taskToProcess <span style="color:#f92672">=</span> taskQueue.GetNextTask();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span>                assert(taskToProcess <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span>                <span style="color:#66d9ef">return</span> taskToProcess;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span>            }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18</span>        }();
</code></pre></div><p>We will try to get out Task using C++17&rsquo;s <code>std::optional</code>. This container allows us to create an instance that may not have a value after initialization. The worker thread will wait for it to be woken up inside of the <code>std::optional</code> constructor. If the task queue has a pending task, we will get it and return it as the value inside the <code>std::optional</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>data) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18</span>            <span style="color:#66d9ef">break</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21</span>        Task<span style="color:#f92672">*</span> taskPtr <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>task;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22</span>        {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23</span>            std<span style="color:#f92672">::</span>scoped_lock<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> guard(coutMutex);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24</span>            std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Worker {&#34;</span> <span style="color:#f92672">&lt;&lt;</span> workerId <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;} is executing task {&#34;</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25</span>                      <span style="color:#f92672">&lt;&lt;</span> taskPtr<span style="color:#f92672">-&gt;</span>GetId() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;}.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26</span>        }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28</span>        <span style="color:#75715e">// process the data
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29</span><span style="color:#75715e"></span>        taskPtr<span style="color:#f92672">-&gt;</span>Execute();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30</span>        <span style="color:#66d9ef">delete</span> taskPtr;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">32</span>}
</code></pre></div><p>If the <code>std::optional</code> returns without a value, the thread ends execution. Otherwise we print a debug message and execute the task.</p>
<p>Let&rsquo;s put it all together in our main function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1</span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> argv[]) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2</span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> thread_pool_size <span style="color:#f92672">=</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3</span>        std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span><span style="color:#f92672">::</span>hardware_concurrency() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4</span>    assert(thread_pool_size <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6</span>    std<span style="color:#f92672">::</span>mutex coutMutex;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8</span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span><span style="color:#f92672">&gt;</span> thread_pool(thread_pool_size);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9</span>    TaskQueue taskQueue;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11</span>    <span style="color:#66d9ef">for</span> (size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> thread_pool_size; <span style="color:#f92672">++</span>i) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12</span>        thread_pool[i] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span>(WorkerThread, i, std<span style="color:#f92672">::</span>ref(taskQueue),
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13</span>                                     std<span style="color:#f92672">::</span>ref(coutMutex));
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14</span>    }
</code></pre></div><p>Here we create an array of worker threads. At this point they will start execution and immediately sleep until we push new tasks.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15</span>    std<span style="color:#f92672">::</span>random_device rd;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16</span>    std<span style="color:#f92672">::</span>mt19937 gen(rd());
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17</span>    std<span style="color:#f92672">::</span>uniform_int_distribution<span style="color:#f92672">&lt;&gt;</span> taskDuration(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1000</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19</span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">5</span>; <span style="color:#f92672">++</span>i) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20</span>        taskQueue.PushTask(
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21</span>            <span style="color:#66d9ef">new</span> Task(i, std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>milliseconds(taskDuration(gen)),
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22</span>                     std<span style="color:#f92672">::</span>ref(coutMutex)));
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25</span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>Task<span style="color:#f92672">*&gt;</span> taskBatch;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26</span>    taskBatch.resize(<span style="color:#ae81ff">5</span>);
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27</span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">5</span>; <span style="color:#f92672">++</span>i) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28</span>        taskBatch[i] <span style="color:#f92672">=</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29</span>            <span style="color:#66d9ef">new</span> Task(i <span style="color:#f92672">+</span> <span style="color:#ae81ff">5</span>, std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>milliseconds(taskDuration(gen)),
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30</span>                     std<span style="color:#f92672">::</span>ref(coutMutex));
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">32</span>    taskQueue.PushTasks(taskBatch);
</code></pre></div><p>Usually, the producer thread is also a loop that creates tasks until the program finishes. For our example, we will create only 10 tasks with random durations. The duration is a random value from 0 to 1000 milliseconds.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">33</span>    std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>sleep_for(std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>seconds(<span style="color:#ae81ff">10</span>));
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">34</span>    taskQueue.StopQueue();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">35</span>
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">36</span>    <span style="color:#66d9ef">for</span> (size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> thread_pool_size; <span style="color:#f92672">++</span>i) {
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">37</span>        thread_pool[i].join();
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">38</span>    }
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">39</span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
<span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">40</span>}
</code></pre></div><p>To make the end of our program simple, we will sleep the producer thread for 10 seconds to hopefully process all tasks, and stop the queue. In the last statement, we wait for all consumers to finish, and we exit the program.</p>
<p>An example output of this program may be:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Worker <span style="color:#f92672">{</span>0<span style="color:#f92672">}</span> is executing task <span style="color:#f92672">{</span>0<span style="color:#f92672">}</span>.
Worker <span style="color:#f92672">{</span>1<span style="color:#f92672">}</span> is executing task <span style="color:#f92672">{</span>1<span style="color:#f92672">}</span>.
Worker <span style="color:#f92672">{</span>2<span style="color:#f92672">}</span> is executing task <span style="color:#f92672">{</span>2<span style="color:#f92672">}</span>.
Worker <span style="color:#f92672">{</span>3<span style="color:#f92672">}</span> is executing task <span style="color:#f92672">{</span>3<span style="color:#f92672">}</span>.
Worker <span style="color:#f92672">{</span>4<span style="color:#f92672">}</span> is executing task <span style="color:#f92672">{</span>4<span style="color:#f92672">}</span>.
Task <span style="color:#f92672">{</span>4<span style="color:#f92672">}</span> finished in 418ms.
Worker <span style="color:#f92672">{</span>4<span style="color:#f92672">}</span> is executing task <span style="color:#f92672">{</span>5<span style="color:#f92672">}</span>.
Task <span style="color:#f92672">{</span>3<span style="color:#f92672">}</span> finished in 526ms.
Worker <span style="color:#f92672">{</span>3<span style="color:#f92672">}</span> is executing task <span style="color:#f92672">{</span>6<span style="color:#f92672">}</span>.
Task <span style="color:#f92672">{</span>5<span style="color:#f92672">}</span> finished in 179ms.
Worker <span style="color:#f92672">{</span>4<span style="color:#f92672">}</span> is executing task <span style="color:#f92672">{</span>7<span style="color:#f92672">}</span>.
Task <span style="color:#f92672">{</span>2<span style="color:#f92672">}</span> finished in 640ms.
Worker <span style="color:#f92672">{</span>2<span style="color:#f92672">}</span> is executing task <span style="color:#f92672">{</span>8<span style="color:#f92672">}</span>.
Task <span style="color:#f92672">{</span>1<span style="color:#f92672">}</span> finished in 781ms.
Worker <span style="color:#f92672">{</span>1<span style="color:#f92672">}</span> is executing task <span style="color:#f92672">{</span>9<span style="color:#f92672">}</span>.
Task <span style="color:#f92672">{</span>6<span style="color:#f92672">}</span> finished in 277ms.
Task <span style="color:#f92672">{</span>0<span style="color:#f92672">}</span> finished in 912ms.
Task <span style="color:#f92672">{</span>7<span style="color:#f92672">}</span> finished in 337ms.
Task <span style="color:#f92672">{</span>8<span style="color:#f92672">}</span> finished in 527ms.
Task <span style="color:#f92672">{</span>9<span style="color:#f92672">}</span> finished in 861ms.
</code></pre></div>
    </div>
    
      
        <div class="pagination">
          <div class="pagination__title">
            <span class="pagination__title-h"
              >Read other posts</span
            >
            <hr />
          </div>
          <div class="pagination__buttons">
            
              <span class="button previous">
                <a href="https://eariassoto.github.io/post/memory-allocators-part-1/">
                  <span class="button__icon">←</span>
                  <span class="button__text">Memory allocators in C&#43;&#43; - Part 1</span>
                </a>
              </span>
            
            
              <span class="button next">
                <a href="https://eariassoto.github.io/post/smart-pointers-cpp-good-practices/">
                  <span class="button__text">Make your pointers smart - C&#43;&#43; good practices</span>
                  <span class="button__icon">→</span>
                </a>
              </span>
            
          </div>
        </div>
      
    

    
      
        

      
    
  </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <a
  href="/"
  class="logo"
  style="text-decoration: none;"
>
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367" />
</svg>
</span>
    <span class="logo__text"
      >Emmanuel Arias</span
    >
    
  
</a>

      <div class="copyright">
        <span
          >© 2022 Powered by
          <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a></span
        >
        <span>
          <a href="https://github.com/eariassoto/hugo-theme-hello-friend" target="_blank" rel="noopener">Theme</a> created by
          <a href="https://twitter.com/panr" target="_blank" rel="noopener">panr</a>
        </span>
      </div>
    
  </div>
</footer>

<script src="https://eariassoto.github.io/assets/main.js"></script>
<script src="https://eariassoto.github.io/assets/prism.js"></script>


      
    </div>

    
  </body>
</html>
