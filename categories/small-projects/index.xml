<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Small Projects on Emmanuel Arias</title>
    
    
    
    <link>https://eariassoto.github.io/categories/small-projects/</link>
    <description>Recent content in Small Projects on Emmanuel Arias</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 10 Sep 2017 18:03:18 -0600</lastBuildDate>
    
	<atom:link href="https://eariassoto.github.io/categories/small-projects/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>First Steps With Go</title>
      <link>https://eariassoto.github.io/post/first-steps-with-go/</link>
      <pubDate>Sun, 10 Sep 2017 18:03:18 -0600</pubDate>
      
      <guid>https://eariassoto.github.io/post/first-steps-with-go/</guid>
      <description>
        
          
          
          
        
        
        
          &lt;p&gt;Go is a simple and powerful programming language. Its syntax is familiar to C/C++ but it definately has improvements in comparison. It has a bunch of great features such as static types, memory safety, garbage collection, and it is targeted to concurrent programming. I discovered it very recently, so I want to start simple and learn the basics of this language. In this post, we will write our first Go program and library. Also, we will learn how to unit tests our Go programs.&lt;/p&gt;
          
        
        </description>
    </item>
    
    <item>
      <title>Source-to-source compilation with Lex-Yacc</title>
      <link>https://eariassoto.github.io/post/source-to-source-compilation-with-lex-yacc/</link>
      <pubDate>Sat, 15 Jul 2017 10:43:23 -0600</pubDate>
      
      <guid>https://eariassoto.github.io/post/source-to-source-compilation-with-lex-yacc/</guid>
      <description>
        
          
          
          
        
        
        
          &lt;p&gt;In this post, I will describe a source-to-source compiler that transforms a Brainfuck program into its equivalent 64 bits assembly code. The assembly program can be built into a executable, thus allowing you to run Brainfuck programs natively.&lt;/p&gt;
          
        
        </description>
    </item>
    
  </channel>
</rss>